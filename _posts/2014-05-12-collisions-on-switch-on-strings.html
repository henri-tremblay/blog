---
layout: post
title: Collisions on a Switch on Strings
date: '2014-05-12T16:17:00.001-07:00'
author: Henri Tremblay
tags:
- What I learned today
modified_time: '2014-05-12T16:17:53.297-07:00'
blogger_id: tag:blogger.com,1999:blog-8282654404214414992.post-6639709329413708670
blogger_orig_url: http://blog.tremblay.pro/2014/05/collisions-on-switch-on-strings.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">Today, I felt on a really nice <a href="http://javarevisited.blogspot.fr/2014/05/how-string-in-switch-works-in-java-7.html" target="_blank" rel="nofollow noopener noreferrer">blog post </a>about how a switch is implemented for String under the hood.<br /><br />It basically explains that the switch is implemented on the String hash code. Easy and efficient. But it made me wondering what would happen if the was a collision in the hash codes. By that I mean: What happen if you got two cases containing strings having the same hash code?<br /><br />To test it, I've created such a switch. First I was needing to found two strings with the same hash code. The way the hash code of calculate for a string is quite simple. It loops over the characters, adding their value to the previous result multiplied by 31. So, doing a bit of algebra, the two characters strings below will be in collision.<br /><br /><pre class="prettyprint java"><br />int c1 = some_character, c2 = some_other_character;<br />int c3 = c1-1, c4 = 31*c1+c2-31*c3;<br /><br />String s1 = new String(new char[] {(char)c1, (char)c2});<br />String s2 = new String(new char[] {(char)c3, (char)c4});<br /></pre>From where I just had to create a switch with the result. For instance "10" and "0O" both have a hash code of&nbsp;1567.<br /><br /><pre class="prettyprint java"><br />switch (args[0]) {<br />case "10":<br />&nbsp; &nbsp; System.out.println("Here");<br />&nbsp; &nbsp; break;<br />case "0O":<br />&nbsp; &nbsp; System.out.println("There");<br />&nbsp; &nbsp; break;<br />case "123":<br />&nbsp; &nbsp; System.out.println("Away");<br />&nbsp; &nbsp; break;<br />}<br /></pre><br />Decompiling this code brings a surprising result.<br /><br /><pre class="prettyprint java"><br />String str1 = args[0];int i = -1;<br />switch (str1.hashCode())<br />{<br />case 1567:<br />&nbsp; if (str1.equals("0O")) {<br />&nbsp; &nbsp; i = 1;<br />&nbsp; } else if (str1.equals("10")) {<br />&nbsp; &nbsp; i = 0;<br />&nbsp; }<br />&nbsp; break;<br />case 48690:<br />&nbsp; if (str1.equals("123")) {<br />&nbsp; &nbsp; i = 2;<br />&nbsp; }<br />&nbsp; break;<br />}<br />switch (i)<br />{<br />case 0:<br />&nbsp; System.out.println("Here");<br />&nbsp; break;<br />case 1:<br />&nbsp; System.out.println("There");<br />&nbsp; break;<br />case 2:<br />&nbsp; System.out.println("Away");<br />}<br /></pre><div><br /></div><div>So, in case of collision, the compiler changes the strategy and add a redirection. It is worthy to mention that the redirection applies even to cases that are not in collision (like "123" in the example).</div><div><br /></div><div>So, unless the JVM manage to optimize this at runtime (which is highly possible), if we are unlucky enough to have a collision in your switch, you code will be slower than if there wasn't any.</div><div><br /></div></div>
