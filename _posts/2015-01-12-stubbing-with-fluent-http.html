---
layout: post
title: Stubbing with fluent-http
date: '2015-01-12T09:52:00.001-08:00'
author: Henri Tremblay
tags:
- What I learned today
modified_time: '2015-02-17T18:57:24.853-08:00'
blogger_id: tag:blogger.com,1999:blog-8282654404214414992.post-604689390732453186
blogger_orig_url: http://blog.tremblay.pro/2015/01/stubbing-with-fluent-http.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">One thing I do quite often if to make sure I can lunch my application offline. For instance, my application needs to access an external system that is only available from my company network.<br /><br />So if I'm offline, it just doesn't work. And I don't like my ideas to go on hold just because I'm not in front of my desk at work or because the remote service is down.<br /><br />Normally I would launch an embedded something (usually jetty) and have it server my stuff. The trick is to save real results from the actual server in some files and then serve these files. It's a bit complex to configure but in the end it works.<br /><br />I use Spring profiles to turn the fake mode on and off.<br /><br />This time, I tried something different. I used <a href="https://github.com/CodeStory/fluent-http" target="_blank">fluent-http</a>. It is a really lightweight web server that gets configured a bit like NodeJS would.<br /><br />I'm quite happy about it so I thought I should share.<br /><br />My first usage was to turn a kinda integration test into a unit test. So I have a test that used to call the real server and that is now calling my fake server. I can in fact launch it in both modes. That's useful to make sure my code it still compliant with the actual server implementation.<br /><br />It looks like this:<br /><br /><pre style="background-color: white; font-family: Menlo; font-size: 12pt;"><span style="color: olive;">@Before</span><span style="color: navy; font-weight: bold;">public void </span>setup() <span style="color: navy; font-weight: bold;">throws </span>Exception {<br />    <span style="color: navy; font-weight: bold;">if</span>(<span style="color: #660e7a; font-weight: bold;">fake</span>) {<br />        initFakeServer();<br />    }<br />}<br /><br /><span style="color: navy; font-weight: bold;">private void </span>initFakeServer() {<br />    <span style="color: #660e7a; font-weight: bold;">server </span>= <span style="color: navy; font-weight: bold;">new </span>WebServer().configure(routes -&gt; routes<br />        .get(<span style="color: green; font-weight: bold;">"/api/stuff"</span>, requestContent(<span style="color: green; font-weight: bold;">"stuff.json"</span>)))<br />    ).start(<span style="color: blue;">9456</span>);<br />}<br /><br /><span style="color: olive;">@After</span><span style="color: navy; font-weight: bold;">public void </span>tearDown() {<br />   &nbsp;<span style="color: navy; font-size: 12pt; font-weight: bold;">if</span><span style="font-size: 12pt;">(</span><span style="color: #660e7a; font-size: 12pt; font-weight: bold;">fake</span><span style="font-size: 12pt;">) {</span></pre><pre style="background-color: white; font-family: Menlo; font-size: 12pt;"><span style="color: #660e7a; font-size: 12pt; font-weight: bold;">        server</span><span style="font-size: 12pt;">.stop();</span></pre><pre style="background-color: white; font-family: Menlo; font-size: 12pt;"><pre style="font-family: Menlo; font-size: 12pt;">    }</pre></pre><pre style="background-color: white; font-family: Menlo; font-size: 12pt;">}<br /><br /><span style="color: navy; font-weight: bold;">private </span>Payload requestContent(String file) {<br />    <span style="color: navy; font-weight: bold;">try </span>{<br />        String content = <span style="color: navy; font-weight: bold;">new </span>String(Files.<span style="font-style: italic;">readAllBytes</span>(Paths.<span style="font-style: italic;">get</span>(<span style="color: green; font-weight: bold;">"src/test/data/stuff"</span>, file)), <span style="color: green; font-weight: bold;">"UTF-8"</span>);<br />        <span style="color: navy; font-weight: bold;">return new </span>Payload(<span style="color: green; font-weight: bold;">"application/json;charset=UTF-8"</span>, content);<br />    } <span style="color: navy; font-weight: bold;">catch </span>(IOException e) {<br />        <span style="color: navy; font-weight: bold;">throw new </span>RuntimeException(e);<br />    }<br />}</pre> Nice and sweet. Fluent-http can also serve static files directly based on the extension if you prefer. But you will then need to match your directory layout with was is normally served by the real server.<br /><br />Two gotchas though:<br /><br /><ul style="text-align: left;"><li>The content type can normally be deduced from the filename extension. However, the json extension wasn't supported. I made a <a href="https://github.com/CodeStory/fluent-http/pull/73" target="_blank">pull request</a> that was merged today so it should be fixed soon</li><li>The dependencies in the maven pom file are a bit more fast than what I was expecting. It might clash with some of your. I'm currently excluding <span style="font-family: Courier New, Courier, monospace;">slf4j-simple</span>. This one should probably be in scope provided in the code</li></ul></div>