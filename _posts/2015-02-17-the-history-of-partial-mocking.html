---
layout: post
title: The history of partial mocking
date: '2015-02-17T18:57:00.000-08:00'
author: Henri Tremblay
tags:
- Stories
modified_time: '2015-03-04T19:25:29.706-08:00'
blogger_id: tag:blogger.com,1999:blog-8282654404214414992.post-3677334224125818897
blogger_orig_url: http://blog.tremblay.pro/2015/02/the-history-of-partial-mocking.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">Someone asked me this week to give some legitimate reasons to use partial mocking. It's indeed a good question. Especially because the EasyMock <a href="http://easymock.org/user-guide.html#mocking-partial" target="_blank" rel="noopener noreferrer">documentation</a> is explicit on telling that using it is probably a code smell.<br /><br />The funny thing about partial mocking is that I've invented it to workaround issues we had at that time (2004... a long long time ago in the computer engineering world). It's only later that we've discovered some legitimate usages.<br /><br />You see, when I first started to work on class mocking, it wasn't possible to bypass the constructor yet (or at least, I wasn't yet digging in the JVM far enough to be able to do so). So, I was using a lot of deductions to find which constructor will be the best to use. The algorithm was something like this:<br /><div style="text-align: left;"></div><ol style="text-align: left;"><li>Try to use the default constructor</li><li>If it's not there, use the constructor with the less parameters and create a mock for each of these parameters</li><li>Pray it won't fail when creating the new instance</li></ol>Frequently, this method would fail because some nasty individual had put really agressive code in a constructor. For instance, I've seen constructors opening sockets...<br /><div style="text-align: left;"><br /></div><div style="text-align: left;">So, to workaround that, I made it possible to select the constructor to use and also to pass real arguments to it. The arguments were not used afterwards. They were just there to prevent the constructor from crashing.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">But then, something worse happened. Some constructors were calling other methods... And since no expectations were set (of course! The mock doesn't exist yet!), mock creation was failing.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Partial mocking was born to solve that.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">I made it possible to prevent some methods to be mocked so when the constructor would call them, they would behave as usual and I'll get my mock. TADA!</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Yes, it was ugly, hacky and I wasn't really proud of it but that was the best I could do at that time (remember: 2004).</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Not so much later, I found a way to bypass the constructor entirely the same way HotSpot was doing it during serialization. The main drawback was that EasyMock was now working only on HotSpot since the code was HotSpot specific.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">The good news are that this code was already used by a bunch of other frameworks like <a href="http://x-stream.github.io/" target="_blank" rel="noopener noreferrer">XStream</a> for instance. So other JVMs were starting to be compliant. I remember asking the JRockit team about it and two minor versions later, it was there.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Still, that's was caused the creation of <a href="http://objenesis.org/" target="_blank" rel="noopener noreferrer">Objenesis</a>. The magic library that creates objects without calling the constructor on any JVM. In fact, Objenesis is not that useful anymore because we have <span style="font-family: Courier New, Courier, monospace;">Unsafe.allocateInstance</span>. <span style="font-family: Courier New, Courier, monospace;">Unsafe</span> also is OpenJDK specific but so many frameworks are using it that pretty much everyone has implemented it. However, I'm still using Objenesis for two reasons:</div><div style="text-align: left;"></div><ol style="text-align: left;"><li>You never know when a JVM won't be compatible with <span style="font-family: Courier New, Courier, monospace;">Unsafe</span></li><li>My benchmarks have shown the using JVM specific code is way faster than using <span style="font-family: Courier New, Courier, monospace;">Unsafe</span></li></ol><div>So I'm staying on Objenesis for now (and there is an instantiator using <span style="font-family: Courier New, Courier, monospace;">Unsafe</span> so there's no drawback using it).<br /><br />Anyway, back to partial mocking.</div><div><br /></div><div>So, we are now able to bypass the constructor and partial mocking was created because we were not able to. Why is it still there?</div><div><br /></div><div>There are two main usages. The first and most legitimate one is to test the <a href="https://en.wikipedia.org/wiki/Template_method_pattern" target="_blank" rel="noopener noreferrer">Template Method Pattern</a>. Let's say you have an abstract base class with abstract methods and concrete methods.</div><pre class="prettyprint java">public abstract class BaseClass {<br />   public boolean beTruthy() {<br />      // stuff<br />      boolean b = doSayTheTruth();<br />      // other stuff<br />      return b;<br />   }<br /><br />   protected abstract boolean doSayTheTruth();<br />}<br /></pre><div>You want to test the concrete ones. <br /><ul style="text-align: left;"><li>You could create a fake implementation, but that's annoying.&nbsp;</li><li>You could just use a real implementation but then it will make you test more than needed.&nbsp;</li><li>Or you could create a partial mock.&nbsp;</li></ul>In fact, when creating a partial mock, EasyMock now automatically considers that abstract methods will be mocked and concrete methods won't.</div><div><br /></div><div>So you could do</div><pre class="prettyprint java">BaseClass myClass = createMockBuilder(BaseClass.class).createMock();<br />expect(myClass.doSayTheTruth()).andReturn(true);<br />replay(myClass);<br />assertTrue(myClass.beTruthy());<br />verify(myClass);<br /></pre><div>How sweet.</div><div><br /></div><div>The other reason is a little bit less legitimate. Let's say you have a class with a bunch of methods calling each others.<br /><br />You would like to test the class but testing everything at once is nearly impossible.<br /><br />A good solution is to test the methods one after the other by using partial mocking.<br /><ol style="text-align: left;"><li>You will test the first method by mocking everything it calls.&nbsp;</li><li>You will then test another method down the stack by mocking everything it calls.&nbsp;</li><li>And so on and so on.</li></ol></div><div>Of course, that's bad code! But if there are no tests, you can't refactor! Step one, the tests. Step two, refactor. And yes, during the refactoring, the need for partial mocking should disappear. But that doesn't mean partial mocking isn't helpful.</div><div><br /></div><div>That's all for today. Happy partial mocking. I hope you find this story interesting and/or useful.</div></div>
