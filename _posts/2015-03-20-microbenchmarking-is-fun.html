---
layout: post
title: Microbenchmarking is fun
date: '2015-03-20T19:27:00.000-07:00'
author: Henri Tremblay
tags:
- What I learned today
modified_time: '2015-03-20T19:27:41.365-07:00'
blogger_id: tag:blogger.com,1999:blog-8282654404214414992.post-4369716863370597193
blogger_orig_url: http://blog.tremblay.pro/2015/03/microbenchmarking-is-fun.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">But time consuming. So always remember that I should have, for instance, read the assembly generated code to be able to explain why an implementation is faster than another. But I don't have that kind of time right now. So I was just toying around.<br /><br />Anyway, a friend of mine has replaced a bunch of <span style="font-family: Courier New, Courier, monospace;">String.replaceAll</span> with a way longer but way faster implementation based on a for loop. I was happy about it.<br /><br />To make a long story short, it has bounced a bit around the internet and has created an <a href="https://github.com/melix/lecharny-challenge" target="_blank">official challenge on github</a>. All this is well <a href="http://thecodersbreakfast.net/index.php?post/2015/03/17/histoire-de-regex" target="_blank">resumed</a>&nbsp;(in French) by Olivier Croisier on his blog.<br /><br />Since I have an interest in performance tuning, I've started to play with it. Being annoying, instead of providing my own implementation, I first had a look at the benchmark implementation itself. Done with <a href="http://openjdk.java.net/projects/code-tools/jmh/" rel="nofollow" target="_blank">JMH</a> (always reassuring to see a benchmark that isn't home made).<br /><br />So, first I asked for unit tests for make sure my implementations were accurate. Then I've extracted the benched methods in a specific class. At first, it was a static class inside the JMH benchmark. JMH is rewriting this class into something else. To be safe, I prefer to put the benched code where it will be for real.<br /><br />After that, I notice an issue. The dataset used was randomly generated at the beginning of the benchmark. So each benched method was receiving a different dataset. Not good to make comparable results. We are now generating a dataset first and then run all benchmarks on it.<br /><br />Finally, I wanted the dataset to be representative of a real file. Some I made some statistics on a real file to get the usual length of lines, occurence of line feeds, etc. This allowed me to change the generator to create a better result.<br /><br />Now I was set. I must confess, my best result is a plain copy of <a href="http://melix.github.io/blog/" target="_blank">CÃ©dric Champeau</a>'s solution with a tiny tuning. I made sub-methods. On my machine (OS X Yosemite, 2.6 GHz Intel Core i7, Java HotSpot 64 bits 1.8.0_40), it's 10% faster. On <a href="https://travis-ci.org/melix/lecharny-challenge" rel="nofollow" target="_blank">Travis</a>, it's not that conclusive.<br /><br />Anyway, now the funny part is that I tried lots of things that should have been more efficient but that are not.<br /><br /><ul style="text-align: left;"><li>Putting the pattern of the regex in a constant should be faster than only recreating it all the time. No. Pretty much the same result</li><li>Adding the missing <i>else</i> in two subsequent <i>ifs</i> should prevent a comparison and be faster. No. It's almost slower</li><li>Using the ternary operator instead of a if can be a bit faster. But not much. But it is different.</li><li>Removing a&nbsp;<i>++</i> that was redundant doesn't change anything</li><li>Use a new array instead of cloning and then writing over a single array. This removes a huge copy. But it's slower. Probably because of page faults.</li><li>Using <i>arraycopy</i> instead of assigning every single character. Much slower</li><li>Using <i>Unsafe</i> to retrieve, allocate and assign. Also much slower. But I'm pretty sure I can improve this one</li></ul><div>As I said, I've not tried to explain the results. I'm just assuming they are valid. <b>Please don't do this at home.</b></div><div><br /></div><div>However, if the results are indeed valid, it seems that the JVM optimisations give counter-intuitive results. Sometime, doing more things if in fact faster.</div><div><br /></div><div>And of course, if you want to try the challenge, it's open to all :-)</div><br /><br /><br /></div>